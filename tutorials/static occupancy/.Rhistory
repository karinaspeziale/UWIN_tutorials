mod
)
for_pred_mt <- data.frame(
pielou_scale = 0,
blur_scale = 0,
animal_weight_scale = pseq,
avid_user = my_average$avid_user,
expertID = my_average$expertID,
user_id = my_average$user
)
# and approximate those intervals, needs lots of simulations
#  to get a smoother line for plotting.
to_plot_mt <- merTools::predictInterval(
mod,
newdata = for_pred_mt,
which = "fixed",
level = 0.95,
n.sims = 30000
)
# convert to a probability
to_plot_mt <- apply(
to_plot_mt,
2,
plogis
)
# the lines are still a little jagged, just going to smooth them out a tiny
#  bit.
to_plot_smooth <- apply(
to_plot_mt,
2,
function(each_col) lowess(x = pseq, y = each_col)$y
)
# get prop success for each species
# Hmm, there are some double species here, not sure why?
species_prop <- model_data %>%
dplyr::group_by(expertID) %>%
dplyr::summarise(
pc = mean(correct),
aws = unique(animal_weight_scale)
) %>%
data.frame()
# and now we are ready to plot using bbplot, it helps to know the range
#  for the x and y axis (it makes better plots I've found).
range(for_pred_mt$animal_weight_scale)
{
bbplot::blank(
xlim = range(for_pred$animal_weight_scale),
ylim = c(0,1),
bty = "l"
)
# add generic axes to x axis
bbplot::axis_blank(1)
# and to y axis
bbplot::axis_blank(2)
# add numbers to x axis
bbplot::axis_text(
side = 1,
line = 0.8,
cex = 1.25
)
# add numbers to y axis
bbplot::axis_text(
side = 2,
line = 0.8,
cex = 1.25,
las = 1
)
# add x axis title
bbplot::axis_text(
"Animal weight (scaled)",
side  = 1,
line = 3,
cex = 1.25
)
# add y axis title
bbplot::axis_text(
"Probability user correct ID's image",
side = 2,
line = 2.75,
cex = 1.25
)
# add predictive interval to figure
bbplot::ribbon(
x = pseq,
y = to_plot_smooth[,c("upr","lwr")],
col = "purple",
alpha = 0.5
)
# add estimated line
lines(
x = pseq,
y = to_plot_smooth[,"fit"],
col = "purple",
lwd = 3
)
points(
x = species_prop$aws,
y = species_prop$pc,
pch = 19,
cex = 1.2
)
}
mod <- readRDS(
"mod_2_test.RDS"
)
## install & load libraries---------------------------------------------------------------
devtools::install_github("ropensci/FedData", force = TRUE)
# ui.R ----
ui <- fluidPage(
titlePanel(""),  # Add a title panel
sidebarLayout(  # Make the layout a sidebarLayout
sidebarPanel(),  # Inside the sidebarLayout, add a sidebarPanel
mainPanel()  # Inside the sidebarLayout, add a mainPanel
)
)
library("shiny")
library("rsconnect")  # For publishing apps online
# ui.R ----
ui <- fluidPage(
titlePanel(""),  # Add a title panel
sidebarLayout(  # Make the layout a sidebarLayout
sidebarPanel(),  # Inside the sidebarLayout, add a sidebarPanel
mainPanel()  # Inside the sidebarLayout, add a mainPanel
)
)
ui <- fluidPage(
titlePanel("Barley Yield"),
sidebarLayout(
sidebarPanel(
selectInput(inputId = "gen",  # Give the input a name "genotype"
label = "1. Select genotype",  # Give the input a label to be displayed in the app
choices = c("A" = "a","B" = "b","C" = "c","D" = "d","E" = "e","F" = "f","G" = "g","H" = "h"), selected = "a"),  # Create the choices that can be selected. e.g. Display "A" and link to value "a"
selectInput(inputId = "colour",
label = "2. Select histogram colour",
choices = c("blue","green","red","purple","grey"), selected = "grey"),
sliderInput(inputId = "bin",
label = "3. Select number of histogram bins",
min=1, max=25, value= c(10)),
textInput(inputId = "text",
label = "4. Enter some text to be displayed", "")
),
mainPanel()
)
)
runApp('E:/GitHub/Coding Club/shiny.R')
# Outputs are created by placing code in the curly brackets ({}) in the server object:
server <- function(input, output) {
output$plot <- renderPlot(ggplot(Barley, aes(x = yield)) +  # Create object called `output$plot` with a ggplot inside it
geom_histogram(bins = 7,  # Add a histogram to the plot
fill = "grey",  # Make the fill colour grey
data = Barley,  # Use data from `Barley`
colour = "black")  # Outline the bins in black
)
}
# Loading Data ----
Barley <- as.data.frame(beaven.barley)
# ui.R ----
ui <-
fluidPage(
titlePanel("Barley Yield"),
sidebarLayout(
position = "right",
sidebarPanel(h3("Inputs for histogram"),
selectInput("gen", "1. Select genotype", choices = c("A" = "a","B" = "b","C" = "c","D" = "d","E" = "e","F" = "f","G" = "g","H" = "h"), selected = "a"),
br(),
selectInput("col", "2. Select histogram colour", choices = c("blue","green","red","purple","grey"), selected = "grey"),
br(),
sliderInput("bin", "3. Select number of histogram bins", min=1, max=25, value= c(10)),
br(),
textInput("text", "4. Enter some text to be displayed", "")),
mainPanel(
plotOutput("myhist"),
tableOutput("mytable"),
textOutput("mytext")
)
)
)
# server.R ----
server <- function(input, output) {
output$myhist <- renderPlot(ggplot(Barley, aes(x = yield)) + geom_histogram(bins = input$bin,
fill = input$col,
group=input$gen,
data=Barley[Barley$gen == input$gen,],
colour = "black"))
output$mytext <- renderText(input$text)
output$mytable <- renderTable(Barley %>%
filter(gen == input$gen) %>%
summarise("Mean" = mean(yield),
"Median" = median(yield),
"STDEV" = sd(yield),
"Min" = min(yield),
"Max" = max(yield)))
}
# Run the app ----
shinyApp(ui = ui, server = server)
library(ggplot2)  # For creating pretty plots
# Run the app ----
shinyApp(ui = ui, server = server)
library(dplyr)  # For filtering and manipulating data
runApp('E:/GitHub/Coding Club/CC-11-Shiny/Example_App')
# For interactive map
library(tidyverse)
library(sf)
library(mapview)
partner_coord <- read_csv("E:/GitHub/Partner_Tracking/UWIN_city_coords.csv")
partner_coord$Latitude <- as.double(partner_coord$Latitude)
partner_coord$Longitude <- as.double(partner_coord$Longitude)
mapview(partner_coord, xcol = "Longitude", ycol = "Latitude", crs = 4326,
grid = FALSE, layer.name = "UWIN partners", color = "gray", alpha = 0)
# For flat map
library(ggplot2)
library(dplyr)
partner_df <- as.data.frame(partner_coord, region = "City")
coords = sf::st_as_sf(               #sf = spatial tool
partner_coord,
coords = c("Longitude", "Latitude"),
crs = 4326)
sort(unique(ggplot2::map_data("world")$region)) #region options
world_map = map_data("world")
USA = map_data("world", region = "USA")
Canada = map_data("world", region = "Canada")
Germany = map_data("world", region = "Germany")
South.Africa = map_data("world", region = "South Africa")
Madagascar = map_data("world", region = "Madagascar")
Mexico = map_data("world", region = "Mexico")
# colors: http://sape.inf.usi.ch/quick-reference/ggplot2/colour
map <- ggplot(world_map, aes(x = long, y = lat, group = group)) +
geom_polygon(fill="gray", colour = "white")+
geom_polygon(data = USA, fill = "#CCCC66")+
geom_polygon(data = Canada, fill = "#669933")+
geom_polygon(data = Germany, fill = "#FFCC66")+
geom_polygon(data = South.Africa, fill = "#99CC00")+
geom_polygon(data = Madagascar, fill = "#CC9966")+
geom_polygon(data = Mexico, fill = "#CC6633")+
geom_point(data = partner_df, aes(x = Longitude, y = Latitude), inherit.aes = FALSE, pch = 21, fill = "black", color = "black")+
theme_bw()+
# theme(legend.position = "none",
#       panel.grid = element_blank(),
#       axis.title = element_blank(),
#       panel.border = element_blank(),
#       axis.text = element_blank(),
#       axis.ticks = element_blank(),
#       axis.line = element_line(colour = "gray"))+
xlim(-175,75)+
ylim(-70,75)+
theme(panel.border = element_blank(), panel.grid.major = element_blank(),
panel.grid.minor = element_blank(), axis.line = element_line(colour = "gray"))+
theme_void()
print(map)
# Load libraries----------------------------------------------------------------
library(tidyverse)
library(lubridate)
library(dplyr)
# reading in data---------------------------------------------------------------
model_data = data.table::fread("Data/model_data.csv", data.table = FALSE)
library(uwinutils)
connect2db()
# get the study area
area <- "POCA"
remove_started <- TRUE # If partners want all photogroups removed regardless of progress
# last names of users (make sure unique for study area)
last_names <- c(
"Villarreal"
)
# grabs area ID
sa <- SELECT(
paste0(
"select sa.areaID, sa.areaAbbr from StudyAreas sa\n",
"where sa.areaAbbr = '",area,"';"
)
)
# Get users
users <- SELECT(
paste0(
"select * from Users us\n",
"where us.areaID = ", sa$areaID,";"
)
)
users <- users[order(users$lastName),]
# SUB-QUERY down, need to modify based on info given.
users <- users[users$lastName %in% last_names,]
users
# Does number of rows = length of last name vector (check we are grabbing right user)
# check "users" now, is this who you want to delete?
if(nrow(users) != length(last_names)){
stop("query of users wrong")
}
# Get the photo groups assigned to each users
# Can see which groups they are working on
# if there is data downstream must delete, such as tagIndex
apg <- SELECT(
paste0(
"select * from AssignedPhotoGroup apg\n",
"where apg.userID IN", sql_IN(users$userID, FALSE),
" and apg.completed = 0;"
)
)
# pull these photo groups
pg <- SELECT(
paste0(
"select * from PhotoGroup pg\n",
"where pg.photoGroupID IN ",
sql_IN(apg$photoGroupID, FALSE),";"
)
)
apg <- apg[apg$photoGroupID %in% pg$photoGroupID,]
apg <- filter(apg, photoGroupID %in% c(26583,26587, 26590,28763,28777, 28808))
# filter to specific photogroups if necessary
library(dplyr)
apg <- filter(apg, photoGroupID %in% c(26583,26587, 26590,28763,28777, 28808))
apg
# this related to TRUE/FALSE statement about starting tagging photogroups
if(!remove_started){
apg <- apg[-which(apg$tagIndex>0),]
}
# run to delete
if(any(apg$tagIndex>0, na.rm = TRUE)){
to_go <- apg[which(apg$tagIndex>0),]
for(i in 1:nrow(to_go)){
tmp_ph <- SELECT(
paste0(
"SELECT  de.detectionID, de.userID, de.valStatID, ph.photoName from Photos ph\n",
"inner join Detections de on ph.photoName = de.photoName\n",
"where ph.photoGroupID = ", to_go$photoGroupID[i],
" and de.userID = ", to_go$userID[i]
)
)
# make sure none of the photos are validated
if(!all(tmp_ph$valStatID == 1)){
stop()
}
# if not, delete the detections
tmp_qry <- paste0(
"delete from Detections\n",
"where userID = ", to_go$userID[i],
" and photoName IN ", sql_IN(tmp_ph$photoName)
)
MODIFY(tmp_qry)
}}
#deletes everything (all records) but will fail with downstream data
for(i in 1:nrow(apg)){
tmp_qry <- paste0(
"delete from AssignedPhotoGroup\n",
"where photoGroupID = ", apg$photoGroupID[i],
" and userID = ", apg$userID[i],";"
)
MODIFY(tmp_qry, TRUE)
}
# Load in libraries
library(dplyr)
library(ggplot2)
# Set your local working directory
setwd("E:/GitHub/UWIN_tutorials/tutorials/static occupancy")
raccoon <- read.csv("chicago_raccoon.csv", head = TRUE, skip = 3)
# Check out what data we're working with.
head(raccoon)
### Make a comment that 170 sites comes from environment NOT head() function
### also check out skim package
install.packages("skimr")
library(skimr)
skim(raccoon)
# Let's confirm that there are no repeated sites
length(unique(raccoon$Site))
# Great, no repeats! Now let's collapse our data into 6-day sampling occasions. Let's grab all the columns that start with day...
day_cols <- raccoon[,grep("^Day_",colnames(raccoon))]
day_cols
# split them into six day groups...
n_weeks <- ceiling(ncol(day_cols)/6)
n_weeks
ncol(day_cols)
week_groups <- rep(1:n_weeks, each = 6)[1:ncol(day_cols)]
week_groups
### and write a function that keeps each occasion with all NA's as such and those with all 0's as 0,
# and those with at least 1 detection, as 1
combine_days <- function(y, groups){
ans <- rep(NA, max(groups))
for(i in 1:length(groups)){
tmp <- as.numeric(y[groups == i])
if(all(is.na(tmp))){
next
} else {
ans[i] <- as.numeric(sum(tmp, na.rm = TRUE)>0)
}
}
return(ans)
}
combine_days
# Apply this function across rows (in groups of 6)
week_summary <- t( # this transposes our matrix
apply(
day_cols,
1, # 1 is for rows
combine_days,
groups = week_groups
)
)
# Now update names
colnames(week_summary) <- paste0("Week_",1:n_weeks)
week_summary
raccoon_wk <- raccoon[,-grep("^Day_", colnames(raccoon))]
raccoon_wk
raccoon_wk <- cbind(raccoon_wk, week_summary)
raccoon_wk
landcover <- read.csv("Chicago_NLCD_landcover.csv", head = TRUE)
head(landcover)
# Let's join this dataset to our raccoon data. First we need to make sure 'sites' are named the same to join these datasets
colnames(raccoon_wk)
colnames(landcover)
# we'll go ahead and rename 'sites' to 'Site' in the 'landcover' dataset
landcover <- rename(landcover, Site = sites)
# Now we can join our datasets and drop NA's.
raccoon_wk <- left_join(raccoon_wk, landcover, by = 'Site') %>%
na.omit(.)
install.packages("unmarked")
library("unmarked")
y <- raccoon_wk %>%
select(Week_1:Week_5)
siteCovs <- raccoon_wk %>%
select(c(water, forest))
# We should also examine our covariates of interest to see if they should be scaled
hist(raccoon_wk$water)
# We should also examine our covariates of interest to see if they should be scaled
hist(raccoon_wk$water)
ggplot(raccoon_wk, aes(x = water)) +
geom_histogram()
ggplot(raccoon_wk, aes(x = water)) +
geom_histogram(alpha = .5)
ggplot(raccoon_wk, aes(x = water)) +
geom_histogram() +
theme_light(text = element_text(size = 20))
ggplot(raccoon_wk, aes(x = water)) +
geom_histogram() +
theme(text = element_text(size = 20))
ggplot(raccoon_wk, aes(x = water)) +
geom_histogram() +
theme(text = element_text(size = 18)) +
labs(x = "Proportion water", y = "Site count")
ggplot(raccoon_wk, aes(x = water)) +
geom_histogram() +
theme_classic(text = element_text(size = 18)) +
labs(x = "Proportion water", y = "Site count")
ggplot(raccoon_wk, aes(x = water)) +
geom_histogram() +
theme_light(text = element_text(size = 18)) +
labs(x = "Proportion water", y = "Site count")
ggplot(raccoon_wk, aes(x = water)) +
geom_histogram() +
theme_minimal() =
theme(text = element_text(size = 18)) +
labs(x = "Proportion water", y = "Site count")
ggplot(raccoon_wk, aes(x = water)) +
geom_histogram() +
theme_minimal() +
theme(text = element_text(size = 18)) +
labs(x = "Proportion water", y = "Site count")
ggplot(raccoon_wk, aes(x = forest)) +
geom_histogram() +
theme_minimal() +
theme(text = element_text(size = 18)) +
labs(x = "Proportion forest", y = "Site count")
ggsave("water_hist.tiff", width = 6, height = 6)
ggplot(raccoon_wk, aes(x = water)) +
geom_histogram() +
theme_minimal() +
theme(text = element_text(size = 18)) +
labs(x = "Proportion water", y = "Site count")
ggsave("forest_hist.tiff", width = 6, height = 6)
ggplot(raccoon_wk, aes(x = forest)) +
geom_histogram() +
theme_minimal() +
theme(text = element_text(size = 18)) +
labs(x = "Proportion forest", y = "Site count")
ggsave("water_hist.tiff", width = 4)
ggplot(raccoon_wk, aes(x = water)) +
geom_histogram() +
theme_minimal() +
theme(text = element_text(size = 18)) +
labs(x = "Proportion water", y = "Site count")
ggsave("forest_hist.tiff", width = 4)
ggplot(raccoon_wk, aes(x = forest)) +
geom_histogram() +
theme_minimal() +
theme(text = element_text(size = 18)) +
labs(x = "Proportion forest", y = "Site count")
ggsave("water_hist.png", width = 4)
ggplot(raccoon_wk, aes(x = water)) +
geom_histogram() +
theme_minimal() +
theme(text = element_text(size = 18)) +
labs(x = "Proportion water", y = "Site count")
ggsave("forest_hist.png", width = 4)
ggplot(raccoon_wk, aes(x = forest)) +
geom_histogram() +
theme_minimal() +
theme(text = element_text(size = 18)) +
labs(x = "Proportion forest", y = "Site count")
siteCovs <- siteCovs %>%
mutate(water_scale = scale(water)) %>%
mutate(forest_scale = scale(forest))
siteCovs
# scale covariates
siteCovs <- siteCovs %>%
mutate(water_scale = scale(water)) %>%
mutate(forest_scale = scale(forest))
ggplot(siteCovs, aes(x = water_scale)) +
geom_histogram() +
theme_minimal() +
theme(text = element_text(size = 18)) +
labs(x = "Proportion water", y = "Site count")
View(siteCovs)
hist(siteCovs$forest_scale)
hist(siteCovs$water_scale)
